group llvm;

return(a) ::= "<a>"

returnTwo(a, b) ::= <<
<a>
<b>

>>

declare(var, expr, tmpNum) ::= <<
;evaluating expression
<expr>
;storing expression into variable
%.<var> = alloca i32, align 4
store i32 %.<tmpNum>, i32* %.<var>
>>

llvmProgram(globalStatements) ::= <<
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1

<globalStatements>

declare i32 @printf(i8*, ...)

>>

globalDeclare(varName, varType, varValue, alignment) ::= <<
  @.<varName> = global <varType> <varValue>, align <alignment>
>>

declareProcOrFunc(procName, procVars, procBody, retType, retNum) ::= <<
define <retType> @<procName>(<procVars>) {
entry:
  <procBody>
  ret <retType> %.<retNum>
}


>>

declareVoidProcOrFunc(procName, procVars, procType, procBody) ::= <<
define <retType> @<procName>(<procVars>) {
entry:
  <procBody>
  ret void
}


>>

paramsep(params) ::= << <params:{ a |<a>}; separator=", "> >>

param(name, type) ::= << <type> %<name>
>>



outputAssi(varName, varType, expr, tmpNum) ::= <<
;start outputAssi
<expr>

%.<varName> = alloca <varType>, align 4
store <varType> %.<tmpNum>, <varType>* %.<varName>
;end outputAssi
>>

load_num(tmpNum, value, varType) ::= <<
;start load_num
%.temp<tmpNum> = alloca <varType>, align 4
store <varType> <value>, <varType>* %.temp<tmpNum>
%.<tmpNum> = load <varType>* %.temp<tmpNum>
;end load_num

>>

load_var(tmpNum, var, varType) ::= <<
;start load_var
%.<tmpNum> = load <varType>* %.<var>
;end load_var

>>

print(expr, type, result) ::= <<

<expr>
call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), <type> %.<result>)

>>

returnStat(val, tmpNum, type) ::= <<
<val>
ret <type> %.<tmpNum>

>>

returnVoid() ::= "ret void"

//?
cast(varType, expr, castType) ::= <<
;start cast
resultthing = bitcast <varType> <expr> to <castType>
;end cast

>>

compare(expr1, expr2, comparison, operator, type, tmpNum1, tmpNum2, result) ::= <<
;start equals
<expr1>
<expr2>

%.bool<result> = <comparison> <operator> <type> %.<tmpNum1>, %.<tmpNum2>
%.<result> = select i1 %.bool<result>, i32 1, i32 0
;end equals
>>

arithmetic(expr1, expr2, operator, type, tmpNum1, tmpNum2, result) ::= <<
;start arithmetic
<expr1>
<expr2>
%.<result> = <operator> <type> %.<tmpNum1>, %.<tmpNum2>
;end arithmetic

>>

ifStatement(condition, body, tmpNum) ::= <<
;start if conditional
<condition>
%.notZero<tmpNum> = icmp ne i32 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<tmpNum>, label %.skip<tmpNum>
.body<tmpNum>:
<body>
br label %.skip<tmpNum>
.skip<tmpNum>:
;end if conditional

>>

ifElseStatement(condition, body, elseBody, tmpNum) ::= <<
;start if conditional
<condition>
%.notZero<tmpNum> = icmp ne i32 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<tmpNum>, label %.elseBody<tmpNum>
.body<tmpNum>:
<body>
br label %.finished<tmpNum>
.elseBody<tmpNum>:
<elseBody>
br label %.finished<tmpNum>
.finished<tmpNum>:
;end if conditional

>>


loopStatement(condition, body, tmpNum) ::= <<
;start loop conditional
br label %.startloop<tmpNum>
.startloop<tmpNum>:
<condition>
%.notZero<tmpNum> = icmp ne i32 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<tmpNum>, label %.endloop<tmpNum>
.body<tmpNum>:
<body>
br label %.startloop<tmpNum>
.endloop<tmpNum>:
;end loop conditional

>>