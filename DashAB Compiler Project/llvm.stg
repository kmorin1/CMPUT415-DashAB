group llvm;

return(a) ::= "<a>"

returnTwo(a, b) ::= <<
<a>
<b>

>>

declare(var, expr, tmpNum) ::= <<
;evaluating expression
<expr>
;storing expression into variable
%.<var> = alloca i32, align 4
store i32 %.<tmpNum>, i32* %.<var>
>>

llvmProgram(globalStatements) ::= <<
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

<globalStatements>

declare i32 @printf(i8*, ...)

declare i32 @power_i32(i32, i32)

declare i32 @print_i32(i32)

declare float @print_float(float)

declare i1 @print_i1(i1)

declare i8 @print_i8(i8)

declare i32 @input_i32(i32*)

declare float @input_float(float*)

declare i1 @input_i1(i1*)

declare i8 @input_i8(i8*)

declare i32 @stream_state()

declare float @implicit_promotion(i32)

>>

globalDeclare(varName, varType, varValue, alignment) ::= <<
  @.<varName> = global <varType> <varValue>, align <alignment>
>>

declareProcOrFunc(procName, procVars, procBody, retType, retNum) ::= <<
define <retType> @<procName>(<procVars>) {
entry:
  <procBody>
}


>>

declareVoidProcOrFunc(procName, procVars, procType, procBody) ::= <<
define <retType> @<procName>(<procVars>) {
entry:
  <procBody>
  ret void
}


>>

paramsep(params) ::= << <params:{ a |<a>}; separator=", "> >>

param(name, type) ::= << <type> %<name>
>>


outputDecl(varName, varType, expr, tmpNum) ::= <<
;start outputDecl
<expr>

%.<varName> = alloca <varType>, align 4
store <varType> %.<tmpNum>, <varType>* %.<varName>
;end outputDecl

>>

outputEmptyDecl(varName, varType, value) ::= <<
;start outputEmptyDecl
%.<varName> = alloca <varType>, align 4
store <varType> <value>, <varType>* %.<varName>
;end outputEmptyDecl

>>

outputAssi(varName, varType, expr, tmpNum) ::= <<
;start outputAssi
<expr>

store <varType> %.<tmpNum>, <varType>* %.<varName>
;end outputAssi

>>

load_num(tmpNum, value, varType) ::= <<
;start load_num
%.temp<tmpNum> = alloca <varType>, align 4
store <varType> <value>, <varType>* %.temp<tmpNum>
%.<tmpNum> = load <varType>* %.temp<tmpNum>
;end load_num

>>

load_var(tmpNum, var, varType) ::= <<
;start load_var
%.<tmpNum> = load <varType>* %.<var>
;end load_var

>>

load_bool(tmpNum, value, varType) ::= <<
;start load_bool
%.temp<tmpNum> = alloca <varType>, align 1
store <varType> <value>, <varType>* %.temp<tmpNum>
%.<tmpNum> = load <varType>* %.temp<tmpNum>
;end load_bool

>>

load_char(tmpNum, value, varType) ::= <<
;start load_char
%.temp<tmpNum> = alloca <varType>, align 1
store <varType> <value>, <varType>* %.temp<tmpNum>
%.<tmpNum> = load <varType>* %.temp<tmpNum>
;end load_char

>>

print(expr, type, result) ::= <<
;start print
<expr>
call <type> (<type>)* @print_<type>(<type> %.<result>)
;end print

>>

input(varName, varType) ::= <<
;start input
call <varType> (<varType>*)* @input_<varType>(<varType>* %.<varName>)
;end input

>>

streamState(tmpNum) ::= <<
;start stream state
%.<tmpNum> = call i32 ()* @stream_state()
;end stream state

>>

returnStat(expr, tmpNum, type) ::= <<
;start return
<expr>
ret <type> %.<tmpNum>
;end return

>>

returnVoid() ::= "ret void"

//?
cast(func, expr) ::= <<
;start cast
<expr>
<func>
;end cast

>>

call(funcName, retType) ::= "nope"

negative(tmpNum, expr, zero, result, operator) ::= <<
;start negative
<expr>

%.<result> = <operator> <type> <zero>, %.<tmpNum>
;end negative

>>

not(expr, type, tmpNum, result) ::= <<
;start not
<expr>
%.<result> = xor i1 1, %.<tmpNum>
;end not  

>>

compare(expr1, expr2, comparison, operator, type, tmpNum1, tmpNum2, result) ::= <<
;start equals
<expr1>
<expr2>

%.bool<result> = <comparison> <operator> <type> %.<tmpNum1>, %.<tmpNum2>
%.<result> = select i1 %.bool<result>, i1 1, i1 0
;end equals

>>

arithmetic(expr1, expr2, operator, type, tmpNum1, tmpNum2, result, promote1, promote2) ::= <<
;start arithmetic
<expr1>
<expr2>
<promote1>
<promote2>
%.<result> = <operator> <type> %.<tmpNum1>, %.<tmpNum2>
;end arithmetic

>>

ifStatement(condition, body, tmpNum) ::= <<
;start if conditional
<condition>
%.notZero<tmpNum> = icmp ne i1 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<tmpNum>, label %.skip<tmpNum>
.body<tmpNum>:
<body>
br label %.skip<tmpNum>
.skip<tmpNum>:
;end if conditional

>>

ifElseStatement(condition, body, elseBody, tmpNum) ::= <<
;start if else conditional
<condition>
%.notZero<tmpNum> = icmp ne i1 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<tmpNum>, label %.elseBody<tmpNum>
.body<tmpNum>:
<body>
br label %.finished<tmpNum>
.elseBody<tmpNum>:
<elseBody>
br label %.finished<tmpNum>
.finished<tmpNum>:
;end if else conditional

>>


whileLoop(condition, body, tmpNum, loopNum) ::= <<
;start while loop
br label %.startloop<loopNum>
.startloop<loopNum>:
<condition>
%.notZero<tmpNum> = icmp ne i1 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<loopNum>, label %.endloop<loopNum>
.body<loopNum>:
<body>
br label %.startloop<loopNum>
.endloop<loopNum>:
;end while loop

>>

doWhileLoop(condition, body, tmpNum, loopNum) ::= <<
;start do while loop
br label %.body<loopNum>
.body<loopNum>:
<body>
br label %.startloop<loopNum>
.startloop<loopNum>:
<condition>
%.notZero<tmpNum> = icmp ne i1 %.<tmpNum>, 0
br i1 %.notZero<tmpNum>, label %.body<loopNum>, label %.endloop<loopNum>
.endloop<loopNum>:
;end do while loop

>>

infLoop(body, tmpNum, loopNum) ::= <<
;start inf loop
br label %.startloop<loopNum>
.startloop<loopNum>:
<body>
br label %.startloop<loopNum>
.endloop<loopNum>:
;end inf loop

>>

break(loopNum) ::= <<
;start break
br label %.endloop<loopNum>
;end break

>>

continue(loopNum) ::= <<
;start continue
br label %.startloop<loopNum>
;end continue

>>